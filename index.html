<!DOCTYPE html>
<html>

    <head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta charset="UTF-8">
	<title>Плеер</title>
	
	<style>
	    body {
			margin: 0;
			padding: 0;
	    }
	    .player {
			width: 560px;
			height: 115px;
			position: relative;
			background: #8f3fb0;
	    }
	    .player .name {
			line-height: 40px;
			background: #9c56b9;
			color: #fff;
			text-align: center;
	    }
	    .actions {
			position: relative;
			height: 75px;
	    }
	    .actions .pause, .play, .mute, .unmute, .prev, .next {
			height: 42px;
			width: 42px;
			position: absolute;
			bottom: 18px;
			cursor: pointer;
	    }
	    .actions div.play {
			left: 18px;
			background: url("http://indipub.danenkov.ru/files/play_pause_bg.png") bottom center;
	    }
	    .actions div.pause {
			background: url("http://indipub.danenkov.ru/files/play_pause_bg.png") top center;
			left: 18px; 
	    }
	    .actions div.prev {
			background: url("http://indipub.danenkov.ru/files/prev_bg.png") 0 0;
			left: 70px; 
	    }
	    .actions div.next {
			background: url("http://indipub.danenkov.ru/files/next_bg.png") 0 0;
			left: 122px; 
	    }
	    .actions div.mute {
			left: 174px;
			background: url("http://indipub.danenkov.ru/files/volume_bg.png") bottom center;
	    }
	    .actions div.unmute {
			left: 174px;
			background: url("http://indipub.danenkov.ru/files/volume_bg.png") top center;
	    }
	    .timer {
			color: #fff;
			position: absolute;
			left: 75px;
			top: 12px;
			display: block;
	    }
	    .actions .progress {
			position: absolute;
			bottom: 25px;
			left: 240px;
	    }
	    .hide {
			display: none;
	    }
	    .sliderPlaying, .sliderVolume {
			height: 4px;
			background: #cecece;
			position: absolute;
			left: 240px;
			top: 35px;
	    }
	    .sliderVolume {
			left: 400px;
	    }	
	    .slider {
			height: 15px;
			width: 15px;
			position: relative;
			left: 0;
			top: -5px;
			background: white;
			cursor: pointer;
	    }
	    .timeInfo {
			width: 40px;
			position: absolute;
			top: -20px;
			text-align: center;
			color: #fff;
			font-size: 11px;
			display: none;
	    }
	</style>

	
	<script>
	    "use strict";
	    
	    window.onload = function() {

		var MYAPP = MYAPP || {};
		
		MYAPP = (function() {
		    /**
		    * Конструктор объектов, которые умеют оповещать
		    * слушателей о своих событиях.
		    */
		    function CustomEventTarget() {
				//объект, где мы будем хранить ссылки на функции-слушатели
				this._events = {};
		    }
		    
		    CustomEventTarget.prototype = {
				constructor: CustomEventTarget,
				//добавляет слушателя события
				on: function (eventType, listener) {
					var events = this._events,
					listeners;
					if (eventType in events) {
					//если уже есть слушатели такого события
					listeners = events[eventType];
					if (listeners.indexOf(listener) == -1) {
						//проверяем что такого слушателя еще нет
						//и помещаем в список слушателей
						listeners.push(listener);
					}
					} else {
					//если еще нет слушатлей такого события,
					//то добавляем новый массив и сразу
					//помещаем в него слушателя
					events[eventType] = [listener];
					}
				},
		    
				//удаляет слушателя события
				off: function (eventType, listener) {
					//…
				},
		    
				//оповещает слушателей события
				_fire: function(eventType, detail) {
					var listeners = this._events[eventType];
					if (listeners) {
					//console.log(listeners);
					//если есть слушатели такого события,
					//создаем новый объект события
					var event = {
						type: eventType,
						detail: detail
					};
					listeners.forEach(function (listener) {
						//и вызываем каждого слушателя,
						//передавая объект события
						listener.call(this, event);
					}, this);
					}
				}
		    };
		    
		    // щаблонизатор 
		    function template(str) {
				str = (typeof str === "string") ? str : str.innerHTML;
				var p = [];
				p.push('var p = [];p.push(\'' + str
					.replace(/[\r\t\n]/g, "")
					.split("<%").join("\t")
					.replace(/((^|%>)[^\t]*)'/g, "$1\r")
					.replace(/\t=(.*?)%>/g, "',$1,'")
					.split("\t").join("');")
					.split("%>").join("p.push('")
					.split("\r").join("\\'") + '\');return p.join(\'\');');
				return new Function('data', p);
		    };
		    
		    // Итератор -- 04.10.2014
		    var Iterator = function (data) {
				this._data = data;
				this._index = 0;
				this._length = data.length;
		    }
		    
		    Iterator.prototype = {
				constructor: Iterator,
				current: function () {
					return this._data[this._index];  
				},
				rewind: function () {
					this._index = 0; 
				},
				prev: function () {
					if (!this.hasPrev()) {
						return null;
					}
					this._index -= 1;
					return this._data[this._index];
				},
				next: function () {
					if (!this.hasNext()) {
						return null;
					}
					this._index += 1;
					return this._data[this._index];
				},
				hasNext: function () {
					return this._index < this._length - 1;
				},
				hasPrev: function () {
					return this._index > 0;
				}
		    }
		    
		    // ф-я констр. отвеч-я за воспроизвдение.
		    var Player = function () {
				this._audio = new Audio;
				this._canPlay = false; // флаг о полной загрузки файла
				this._play = false; // флаг воспроизведения
				this.changeProgressOnTimer = true;
				// событие canplay возникает, когда объём загруженных мультимедийных данных становится
				// достаточным для того, чтобы успешно начать воспроизведение ролика. Возникает после
				// события loadeddata и перед событием canplaythrough.
				this._audio.addEventListener('canplay', this._onCanPlay.bind(this));
				this._audio.addEventListener('timeupdate', this._onTimer.bind(this));
				this._audio.addEventListener('ended', this._onEnded.bind(this));
				
				CustomEventTarget.call(this); // наследуем свойства от CustomEventTarget
		    }
		    
		    // просто созданим новый объект с прототипом от EventTarget
		    Player.prototype = Object.create(CustomEventTarget.prototype);
		    //восстановим ссылку на конструктор
		    Player.prototype.constructor = Player;
		    //запомним от кого мы наследовали функционал
		    Player.Super = CustomEventTarget; //Super от Super/Parent Class
		    
		    //Player.prototype._source = '';
			
		    Player.prototype._onCanPlay = function () {
				this._canPlay = true;
				
				// оповещаем имя трека, когда трек загружен
				this._fire('changeSource', {source: this._source});
				
				if (this._play) { // если this._play true
					this.play(); // играть сразу
				}
		    };
		    
		    // установка плейлиста -- 04.10.2014
		    Player.prototype.setPlaylist = function (playlist) {
				this._playlist = new Iterator(playlist);
				
				// первоначально ставится первый трек
				if (this._playlist.hasNext()) {
					this._setSource(this._playlist.current());
				}
		    };
		    
		    Player.prototype._setSource = function (source) {
				this._canPlay = false; //сбрасываем флаг о загрузки файла
				this._source = source;
				this._audio.src = this._source; // устанавливаем источник
		    };
			
		    Player.prototype.isPaused = function () {
				return this._audio.paused;
		    };
			
		    Player.prototype.play = function () {
				if (this._canPlay) { // если произошло событие canplay играем сразу
					this._audio.play();
					
					this._fire('play'); //оповещаем подписчика о начале воспроизведения (интерфейс)
				} else {
					this._play = true; //устанавливаем флаг, что по canplay нужно начать воспроизведение
				}
		    };
			
		    Player.prototype.pause = function () {
				this._fire('pause'); //оповещаем подписчика о завершении воспроизведения (интерфейс)
				this._audio.pause();
		    };
		    
		    
		    // установка предидущего трека -- 04.10.2014
		    Player.prototype.prev = function () {
				if (this._playlist.hasPrev()) {
					this._setSource(this._playlist.prev());
					this._play = true;
				}
		    };
		    
		    // установка следующего трека -- 04.10.2014
		    Player.prototype.next = function () {
				if (this._playlist.hasNext()) {
					this._setSource(this._playlist.next());
					this._play = true;
				}
		    };
	
		    Player.prototype._onTimer = function () {
				this._fire('timer', {currentTime: this._audio.currentTime, duration: this.getDuration()});
		    };
		    
		    Player.prototype._onEnded = function () {
				// берем след трек из плейлиста -- 04.10.2014
				if (this._playlist.hasNext()) {
					this._setSource(this._playlist.next());
					this._play = true;
				}
		    };
		    
		    Player.prototype.isMuted = function () {
				return this._audio.muted;
		    };
		    
		    Player.prototype.mute = function () {
				this._fire('mute');
	
				this._audio.muted = true;
		    };
			
		    Player.prototype.unmute = function () {
				this._fire('unmute');
	
				this._audio.muted = false;
		    };
		    
		    Player.prototype.hideTimePlayingChange = function () {
				this._fire('hideTimePlaying');
		    };
		    
		    Player.prototype.hideTimeVolumeChange = function () {
				this._fire('hideTimeVolume');
		    };
		    
		    Player.prototype.changeVolume = function (newTime, progressMax) {
				var volumeValue = 1 / progressMax * newTime;
				this._audio.volume = volumeValue;
				this._fire('progressVolume', {value: newTime, volumeValue: volumeValue});
		    };
		    
		    Player.prototype.changeCurrentTime = function (newTime, progressMax) {
				this._audio.currentTime = this._audio.duration / progressMax * newTime;
				this._fire('progressCurrentTime', {value: newTime, currentTime: this._audio.currentTime, duration: this.getDuration()});
		    };
		    
		    Player.prototype.getDuration = function () {
				var duration = this._audio.duration;
				if (isFinite(duration)) { // Функция isFinite возвращает значение true, если number имеет любое значение, отличное от NaN
					return duration;
				}
				return 0;
		    };
		    
		    // ф-я констр. отвеч-я за интерфейс.
		    var PlayerViewController = function (player) {
				this._player = player; // экземпляр плеера
				this._element = this._createDOMElement(template(this._template)()); // html разметка интерфеса
				this._findElements(); // инициализация элементов
				
				this._initializeEvents(); // инициализация событий
		    }
		    
		    PlayerViewController.prototype = {
				constructor: PlayerViewController,
				_template: [
					'<div class="player">',
					'<span class="timer">00:00 / 00:00</span>',
					'<div class="name"></div>',
					'<div class="actions">',
						'<div class="play"></div>',
						'<div class="prev"></div>',
						'<div class="next"></div>',
						'<div class="mute"></div>',
						'<div class="sliderPlaying"></div>',
						'<div class="sliderVolume"></div>',
					'</div>',
					'</div>'
				].join(''),
				
				_createDOMElement: function (obj) {
					var div = document.createElement('div');
					div.innerHTML = obj;
					return div.firstChild;
				},
				
				_formatTime: function (time) {
					var minutes = Math.floor(time / 60) % 60,
					seconds = Math.floor(time % 60);
				   
					return  (minutes < 10 ? '0' + minutes : minutes) + ':' +
						(seconds < 10 ? '0' + seconds : seconds);
				},
	
				// инициализация элементов интерфейса
				_findElements: function () {
					var element = this._element;
					
					// прокрутка проигрывания
					var sliderPlaying = new Slider();
					sliderPlaying.setMaxValue(130); // в px
					sliderPlaying.setContainer(element.querySelector('.sliderPlaying'));
					sliderPlaying.render();
					
					sliderPlaying.on('change', this._onProgressPlayingChange.bind(this));
					sliderPlaying.on('hideTime', this._onHideTimePlayingChange.bind(this));
					
					this._sliderPlaying = sliderPlaying;
					
					// прокрутка громкости
					var sliderVolume = new Slider();
					sliderVolume.setMaxValue(130);
					sliderVolume.setContainer(element.querySelector('.sliderVolume'));
					sliderVolume.render();
					
					sliderVolume.on('change', this._onProgressVolumeChange.bind(this));
					sliderVolume.on('hideTime', this._onHideTimeVolumeChange.bind(this));
	
					this._sliderVolume = sliderVolume;
					
					// название трека
					this._nameField = element.querySelector('.name');
					
					// полоса прогресса громкости
					//this._progressVolume  = new Slider();
					
					// таймер
					this._timer = element.querySelector('.timer');
					// кнопка play у каждого интерфейса своя
					this._buttonPlay = element.querySelector('.play');
					// кнопка предидущий трек
					this._buttonPrev = element.querySelector('.prev');
					// кнопка следующий трек
					this._buttonNext = element.querySelector('.next');
					// кнопка вкл / выкл звука
					this._buttonMute = element.querySelector('.mute');
				},
				
				// инициализация событий
				_initializeEvents: function () {
					this._player.on('play', this._playView.bind(this));
					this._player.on('pause', this._pauseView.bind(this));
					this._player.on('mute', this._muteView.bind(this));
					this._player.on('unmute', this._unmuteView.bind(this));
					this._player.on('timer', this._timerView.bind(this));
					this._player.on('ended', this._endedView.bind(this));
					this._player.on('changeSource', this._sourceView.bind(this));
					this._player.on('progressCurrentTime', this._progressPlayingView.bind(this));
					this._player.on('progressVolume', this._progressVolumeView.bind(this));
					this._player.on('hideTimePlaying', this._hideTimePlayingView.bind(this));
					this._player.on('hideTimeVolume', this._hideTimeVolumeView.bind(this));
	
	
					// вкл / выкл плеера
					this._buttonPlay.addEventListener('click', this._onPlay.bind(this));
					// предидущий. трек
					this._buttonPrev.addEventListener('click', this._onPrev.bind(this));
					// следующий трек
					this._buttonNext.addEventListener('click', this._onNext.bind(this));
					// вкл / выкл звука
					this._buttonMute.addEventListener('click', this._onMute.bind(this));
					
				},
				
				// показываем кнопку пауза при проигывании плеера
				_playView: function () {
					this._buttonPlay.className = 'pause';
				},
					
				// показываем кнопку плэй при остановке плеера
				_pauseView: function () {
					this._buttonPlay.className = 'play';
				},
				
				// показываем кнопку выкл. звука
				_muteView: function () {
					this._buttonMute.className = 'unmute';
				},
					
				// показываем кнопку вкл. звука
				_unmuteView: function () {
					this._buttonMute.className = 'mute';
				},
				
				// показываем движение ползунка.
				_progressPlayingView: function (event) {
					this._sliderPlaying.move(event.detail.value); // перемещаем ползунок
					this._sliderPlaying.showTime(event.detail.value, this._formatTime(event.detail.currentTime)); // показываем всплывающее время
				},
				// показываем движение ползунка.
				_hideTimePlayingView: function (event) {
					this._sliderPlaying.hideTime();
				},
				
				// показываем движение ползунка.
				_hideTimeVolumeView: function (event) {
					this._sliderVolume.hideTime();
				},
				
				// показываем движение ползунка.
				_progressVolumeView: function (event) {
					this._sliderVolume.move(event.detail.value);
					
					this._sliderVolume.showTime(event.detail.value, Math.ceil(event.detail.volumeValue * 10)); // показываем всплывающее время
				},
				
				// показываем таймер
				_timerView: function (event) {
					if (event.detail.duration) {
						if (this._timer.classList.contains('hide')) {
							this._timer.classList.remove('hide');
							sliderPlayingContainer.classList.remove('hide');
						}
						this._timer.innerHTML = this._formatTime(event.detail.currentTime) + ' / ' + this._formatTime(event.detail.duration);
						if (!this._sliderPlaying.onMouseDown) { // если ползунок проигрывания в бездействии
							this._sliderPlaying.move(Math.round(this._sliderPlaying.getMaxValue() * event.detail.currentTime / event.detail.duration));
						}
					} else {
						var sliderPlayingContainer = this._sliderPlaying.getContainer();
						this._timer.classList.add('hide');
						sliderPlayingContainer.classList.add('hide');
					}
				},
				
				// окончание проигрывания.
				_endedView: function (event) {
					this._sliderPlaying.setMinValue();
					this._buttonPlay.className = 'play';
					this._timer.innerHTML = '00:00 / ' + this._formatTime(event.detail.duration);
				},
				
				// показываем имя трека.
				_sourceView: function (event) {
					var pathName = event.detail.source.split('/');
					this._nameField.innerHTML = pathName[pathName.length - 1];
				},
				
				//действие по нажатию кнопки play / pause
				_onPlay: function (e) {
					if (this._player.isPaused()) {
						this._player.play();
						return;
					}
					this._player.pause();
				},
				
				//действие по нажатию кнопки prev
				_onPrev: function (e) {
					this._player.prev();
				},
				
				//действие по нажатию кнопки next
				_onNext: function (e) {
					this._player.next();
				},
				
				//действие по нажатию кнопки mute
				_onMute: function (e) {
					if (this._player.isMuted()) {
						this._player.unmute();
						return;
					}
					this._player.mute();
				},
				
				_onHideTimePlayingChange: function () {
					this._player.hideTimePlayingChange();  
				},
				
				_onHideTimeVolumeChange: function () {
					this._player.hideTimeVolumeChange();  
				},
				
				_onProgressPlayingChange: function (event) {
					this._player.changeCurrentTime(event.detail.value, event.detail.progressMax);  
				},
				
				_onProgressVolumeChange: function (event) {
					this._player.changeVolume(event.detail.value, event.detail.progressMax);  
				},
				
				//отображает плеер внутри указанного элемента
				renderTo: function (container) {
					container.appendChild(this._element);
				}
		    }
		    
		    // Слайдер
		    var Slider = function () {
				this._element = this._createDOMElement(template(this._template)());
				this._findElements(); // инициализация элементов
				this._initializeEvents();
				this.onMouseDown = false; // флаг о начале движения ползунка
				CustomEventTarget.call(this); // наследуем свойства от CustomEventTarget
		    }
		    
		    // просто созданим новый объект с прототипом от EventTarget
		    Slider.prototype = Object.create(CustomEventTarget.prototype);
		    //восстановим ссылку на конструктор
		    Slider.prototype.constructor = Slider;
		    //запомним от кого мы наследовали функционал
		    Slider.Super = CustomEventTarget; //Super от Super/Parent Class
		    
		    Slider.prototype._template = [
				'<div class="timeInfo"></div>',
				'<div class="slider"></div>',
		    ].join('');
		    
		    Slider.prototype.hideTime = function () {
				this._timeInfo.style.display = 'none';
		    };
		    
		    Slider.prototype.showTime = function (progressValue, value) {
				this._timeInfo.innerHTML = value;
				this._timeInfo.style.left = progressValue - 12 + 'px';  
				this._timeInfo.style.display = 'block';
		    };
		    
		    Slider.prototype.setContainer = function (container) {
				console.log(getComputedStyle(this._slider, '').width);  //  ???
				this._container = container;
				this._container.style.width = this._progressMaxValue + 15 + 'px';  // значение 15 - ширина слайдера. Не могу получить это значение.
		    };
		    
		    Slider.prototype.getContainer = function () {
				return this._container;
		    };
		    
		    Slider.prototype._createDOMElement = function (obj) {
				var wrapper = document.createElement('div');
				wrapper.className = 'wrapper';
				wrapper.innerHTML = obj;
				return wrapper;
		    };
		    
		    Slider.prototype._findElements = function () {
				var element = this._element;
				this._slider = element.querySelector('.slider');
				this._timeInfo = element.querySelector('.timeInfo');
		    };
		    
		    // установка максимального значения 
		    Slider.prototype.setMaxValue = function (maxValue) {
				this._progressMaxValue = maxValue;
		    };
		    
		    Slider.prototype.getMaxValue = function (maxValue) {
				return this._progressMaxValue;
		    };
		    
		    Slider.prototype.setMinValue = function () {
				this._slider.style.left = '0px';
		    };
		    
		    // установка шага
		    Slider.prototype.setStep = function (stepValue) {
				this._step = stepValue;
		    };
		    
		    Slider.prototype.move = function (value) {
				this._slider.style.left = value + 'px';
		    };
		    
		    Slider.prototype.render = function () {
				this._container.appendChild(this._element);
		    };
		    
		    // инициализация событий
		    Slider.prototype._initializeEvents = function () {
				var handlerOnMove = this._setValue.bind(this),
					me = this;
				
				this._slider.addEventListener('mousedown', function (e) {
					me.onMouseDown = true; // флаг, чтобы ф-я document.onmouseup отработала именно когда нажали на ползунок, а не в любое место
					document.addEventListener('mousemove', handlerOnMove);
				});
				
				document.addEventListener('mouseup', function() {
					if (me.onMouseDown) {
						me._fire('hideTime'); // скрываем время над ползунком
						me.onMouseDown = false;
						document.removeEventListener('mousemove', handlerOnMove);
					}
				});
	
				this._slider.addEventListener('dragstart', function () {
					return false;
				});
		    };
		    
		    Slider.prototype._setValue = function (e) {
				var coordsParent = this._getCoords(this._container),
					left = coordsParent.left,
					value = null;
					
				if (e.pageX <= left) {
					value = 0;
				} else if(e.pageX >= left + this._progressMaxValue) {
					value = this._progressMaxValue;
				} else {
					value = e.pageX - left;
				}
				
				this._fire('change', {value: value, progressMax: this._progressMaxValue});
		    };
			
		    Slider.prototype._getCoords = function(elem) {
				var box = elem.getBoundingClientRect(), // координаты объекта относительно документа
					scrollTop = window.pageYOffset, // значение прокрутки
					scrollLeft = window.pageXOffset, // значение прокрутки
					top  = box.top +  scrollTop , // верт координата объекта относительно документа с учетом прокрутки
					left = box.left + scrollLeft;  // гориз. координата объекта относительно документа с учетом прокрутки
					
				return { top: Math.round(top), left: Math.round(left) };
		    };
			
		    return {
				Player: Player,
				PlayerViewController: PlayerViewController,
				Slider: Slider
		    };
		}());
		
		// один плеер
		var player = new MYAPP.Player;
		player.setPlaylist(['http://indipub.danenkov.ru/files/Sweetbox.mp3',
				    'http://indipub.danenkov.ru/files/Basta.mp3',
				    ]);
		
		//player.setSource('http://indipub.danenkov.ru/files/Sweetbox.mp3');
		
		// первый интерфейс первого плеера
		var playerViewController = new MYAPP.PlayerViewController(player);
		playerViewController.renderTo(document.querySelector('.music-player'));
		
		// первый интерфейс первого плеера
		//var playerViewController1 = new MYAPP.PlayerViewController(player);
		//playerViewController1.renderTo(document.querySelector('.music-player1'));
		//
		//// один плеер
		//var player1 = new MYAPP.Player;
		//player1.setSource('http://indipub.danenkov.ru/files/Basta.mp3');
		//
		//// первый интерфейс первого плеера
		//var playerViewController2 = new MYAPP.PlayerViewController(player1);
		//playerViewController2.renderTo(document.querySelector('.music-player2'));
	    }
	</script>
	
    </head>
    
    <body>
		<div class="music-player" style="margin: 50px 0 0 200px;"></div>
		
		<!--<div class="music-player1" style="margin: 50px 0 0 200px;"></div>-->
		
		<!--<div class="music-player2" style="margin: 50px 0 0 200px;"></div>-->
    </body>
</html>
